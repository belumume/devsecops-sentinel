"""Unit tests for the vulnerability scanner Lambda function."""
import json
import pytest
from unittest.mock import patch, MagicMock, Mock
import os
import importlib.util
import sys

# Dynamically import the Lambda function module
lambda_path = os.path.join(os.path.dirname(__file__), '../../src/lambdas/vulnerability_scanner/app.py')
spec = importlib.util.spec_from_file_location("vulnerability_scanner_app", lambda_path)
app = importlib.util.module_from_spec(spec)
sys.modules["vulnerability_scanner_app"] = app
spec.loader.exec_module(app)

# Import the functions we need
lambda_handler = app.lambda_handler
get_dependency_files = app.get_dependency_files
scan_python_dependencies = app.scan_python_dependencies
scan_node_dependencies = app.scan_node_dependencies

class TestVulnerabilityScanner:
    """Test cases for the vulnerability scanner function."""
    
    @pytest.fixture
    def valid_event(self):
        """Create a valid event for testing."""
        return {
            "repo_details": {
                "repository_full_name": "test-org/test-repo",
                "pr_number": 42,
                "commit_sha": "abc123def456"
            }
        }
    
    @pytest.fixture
    def mock_requirements_txt(self):
        """Sample requirements.txt content."""
        return """Django==2.0.1
requests==2.18.4
Pillow==5.0.0"""
    
    @pytest.fixture
    def mock_package_json(self):
        """Sample package.json content."""
        return json.dumps({
            "name": "test-app",
            "dependencies": {
                "lodash": "4.17.4",
                "moment": "2.19.3"
            }
        })
    
    @patch.object(app, 'get_github_token')
    @patch.object(app, 'get_dependency_files')
    @patch.object(app, 'scan_python_dependencies')
    @patch.object(app, 'scan_node_dependencies')
    def test_successful_scan_both_files(self, mock_node_scan, mock_python_scan, 
                                       mock_get_files, mock_token, valid_event,
                                       mock_requirements_txt, mock_package_json):
        """Test successful scan with both Python and Node.js dependencies."""
        # Setup mocks
        mock_token.return_value = "ghp_test_token"
        mock_get_files.return_value = {
            "requirements.txt": mock_requirements_txt,
            "package.json": mock_package_json
        }
        
        mock_python_scan.return_value = [
            {
                "type": "dependency_vulnerability",
                "language": "python",
                "package": "Django",
                "version": "2.0.1",
                "severity": "HIGH",
                "description": "SQL injection vulnerability",
                "vulnerability_id": "CVE-2019-12345",
                "file": "requirements.txt"
            }
        ]
        
        mock_node_scan.return_value = [
            {
                "type": "dependency_vulnerability",
                "language": "nodejs",
                "package": "lodash",
                "severity": "HIGH",
                "description": "Prototype pollution",
                "vulnerability_id": "CVE-2019-67890",
                "file": "package.json"
            }
        ]
        
        # Call handler
        response = lambda_handler(valid_event, {})
        
        # Assertions
        assert response['statusCode'] == 200
        assert response['scanner_type'] == 'vulnerabilities'
        assert len(response['findings']) == 2
        assert response['summary']['total_findings'] == 2
        mock_python_scan.assert_called_once()
        mock_node_scan.assert_called_once()
    
    @patch.object(app, 'get_github_token')
    @patch.object(app, 'get_dependency_files')
    def test_no_dependency_files(self, mock_get_files, mock_token, valid_event):
        """Test when no dependency files are found."""
        mock_token.return_value = "ghp_test_token"
        mock_get_files.return_value = {}
        
        response = lambda_handler(valid_event, {})
        
        assert response['statusCode'] == 200
        assert len(response['findings']) == 0
        assert response['summary']['total_findings'] == 0
    
    def test_missing_repository_name(self):
        """Test handling of missing repository name."""
        event = {"repo_details": {}}
        response = lambda_handler(event, {})
        
        assert response['statusCode'] == 500
        assert 'error' in response
        assert response['findings'] == []
    
    def test_get_dependency_files_success(self):
        """Test successful retrieval of dependency files."""
        with patch.object(app, 'create_session_with_retries') as mock_create_session:
            # Mock tree response
            mock_tree_response = MagicMock()
            mock_tree_response.status_code = 200
            mock_tree_response.json.return_value = {
                "tree": [
                    {"path": "requirements.txt", "type": "blob"},
                    {"path": "frontend/package.json", "type": "blob"},
                    {"path": "backend/requirements.txt", "type": "blob"},
                    {"path": "src", "type": "tree"},
                ]
            }
            
            # Mock file content responses
            mock_req1_response = MagicMock()
            mock_req1_response.status_code = 200
            mock_req1_response.text = "Django==2.0.1"
            
            mock_pkg_response = MagicMock()
            mock_pkg_response.status_code = 200
            mock_pkg_response.text = '{"dependencies": {"lodash": "4.17.4"}}'
            
            mock_req2_response = MagicMock()
            mock_req2_response.status_code = 200
            mock_req2_response.text = "Flask==1.0.0"
            
            # Mock session
            mock_session = MagicMock()
            mock_session.get.side_effect = [
                mock_tree_response,  # Tree API call
                mock_req1_response,  # requirements.txt
                mock_pkg_response,   # frontend/package.json
                mock_req2_response   # backend/requirements.txt
            ]
            mock_create_session.return_value = mock_session
            
            files = get_dependency_files("test/repo", "abc123", "ghp_token")
            
            assert "requirements.txt" in files
            assert "frontend/package.json" in files
            assert "backend/requirements.txt" in files
            assert files["requirements.txt"] == "Django==2.0.1"
            assert files["frontend/package.json"] == '{"dependencies": {"lodash": "4.17.4"}}'
            assert files["backend/requirements.txt"] == "Flask==1.0.0"
    
    def test_get_dependency_files_not_found(self):
        """Test when dependency files are not found."""
        with patch.object(app, 'create_session_with_retries') as mock_create_session:
            # Mock tree response with no dependency files
            mock_tree_response = MagicMock()
            mock_tree_response.status_code = 200
            mock_tree_response.json.return_value = {
                "tree": [
                    {"path": "README.md", "type": "blob"},
                    {"path": "src", "type": "tree"},
                    {"path": ".gitignore", "type": "blob"}
                ]
            }
            
            # Mock session
            mock_session = MagicMock()
            mock_session.get.return_value = mock_tree_response
            mock_create_session.return_value = mock_session
            
            files = get_dependency_files("test/repo", "abc123", "ghp_token")
            
            assert len(files) == 0
    
    def test_scan_python_dependencies_with_vulnerabilities(self):
        """Test Python vulnerability scanning with findings."""
        requirements_content = "Django==2.0.1\nrequests==2.18.4"
        
        mock_result = MagicMock()
        mock_result.returncode = 255  # safety returns non-zero when vulnerabilities found
        mock_result.stdout = json.dumps([
            {
                "package_name": "Django",
                "affected_versions": "<2.2",
                "severity": "HIGH",
                "description": "SQL injection vulnerability",
                "vulnerability_id": "CVE-2019-12345"
            }
        ])
        
        with patch('vulnerability_scanner_app.find_tool', return_value='safety'):
            with patch('vulnerability_scanner_app.subprocess.run', return_value=mock_result):
                with patch('builtins.open', create=True) as mock_open:
                    findings = scan_python_dependencies(requirements_content, "/tmp", "requirements.txt")
                    
                    assert len(findings) == 1
                    assert findings[0]['package'] == "Django"
                    assert findings[0]['severity'] == "HIGH"
                    assert findings[0]['vulnerability_id'] == "CVE-2019-12345"
    
    def test_scan_node_dependencies_with_vulnerabilities(self):
        """Test Node.js vulnerability scanning with findings."""
        package_json_content = json.dumps({
            "dependencies": {"lodash": "4.17.4"}
        })
        
        mock_result = MagicMock()
        mock_result.returncode = 1  # npm audit returns non-zero when vulnerabilities found
        mock_result.stdout = json.dumps({
            "vulnerabilities": {
                "lodash": {
                    "severity": "high",
                    "via": [{
                        "title": "Prototype Pollution",
                        "source": "CVE-2019-67890"
                    }]
                }
            }
        })
        
        with patch('vulnerability_scanner_app.find_tool', return_value='npm'):
            with patch('vulnerability_scanner_app.subprocess.run', return_value=mock_result):
                with patch('builtins.open', create=True) as mock_open:
                    findings = scan_node_dependencies(package_json_content, "/tmp", "package.json")
                    
                    assert len(findings) == 1
                    assert findings[0]['package'] == "lodash"
                    assert findings[0]['severity'] == "HIGH"
    
    @patch.object(app, 'get_github_token')
    def test_error_handling_in_lambda_handler(self, mock_token, valid_event):
        """Test error handling in the main handler."""
        mock_token.side_effect = Exception("Token retrieval failed")
        
        response = lambda_handler(valid_event, {})
        
        assert response['statusCode'] == 500
        assert 'error' in response
        assert response['findings'] == []
        assert response['summary']['total_findings'] == 0 