import os
import json
import re
import logging
import subprocess
import tempfile
from typing import List, Dict, Any, Optional

import boto3
import requests

from sentinel_utils.utils import (
    get_github_token,
    create_session_with_retries,
    format_error_response,
    format_success_response,
    DEFAULT_TIMEOUT
)

# Configure logging
logger = logging.getLogger(__name__)
logger.setLevel(os.environ.get("LOG_LEVEL", "INFO"))

# Initialize AWS clients
secrets_manager = boto3.client("secretsmanager")

# Scanner type constant
SCANNER_TYPE = "vulnerabilities"

# Dependency file names
PYTHON_DEPS_FILE = "requirements.txt"
NODE_DEPS_FILE = "package.json"

def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:
    """
    Lambda handler that scans for vulnerabilities in dependencies using real tools.
    Supports Python (requirements.txt) and Node.js (package.json).
    
    Args:
        event: Lambda event containing repo_details
        context: Lambda context
        
    Returns:
        Standardized response with vulnerability findings
    """
    logger.info("VulnerabilityScannerFunction invoked - REAL scanning")
    
    try:
        repo_details = event.get("repo_details", {})
        repo_full_name = repo_details.get("repository_full_name", "")
        pr_number = repo_details.get("pr_number", 0)
        commit_sha = repo_details.get("commit_sha", "")
        
        if not repo_full_name:
            raise ValueError("Repository name not provided")
        
        logger.info(f"Scanning repository: {repo_full_name}, PR: {pr_number}")
        
        github_token = get_github_token()
        
        dependency_files = get_dependency_files(repo_full_name, commit_sha, github_token)
        
        all_findings = scan_dependencies(dependency_files)
        
        logger.info(f"Vulnerability scan completed. Found {len(all_findings)} total vulnerabilities.")
        
        return format_success_response(SCANNER_TYPE, all_findings)
        
    except Exception as e:
        logger.error(f"Error in vulnerability scanning: {str(e)}", exc_info=True)
        return format_error_response(SCANNER_TYPE, e)

def get_dependency_files(repo_full_name: str, commit_sha: str, github_token: str) -> Dict[str, str]:
    """
    Get dependency files from the repository at a specific commit.
    Now searches entire repository tree for dependency files.
    
    Args:
        repo_full_name: Full name of the repository (org/repo)
        commit_sha: Commit SHA to fetch files from
        github_token: GitHub authentication token
        
    Returns:
        Dictionary mapping file paths to their contents
    """
    dependency_files = {}
    
    headers = {
        "Authorization": f"token {github_token}",
        "Accept": "application/vnd.github.v3+json"
    }
    
    # Create session with retries
    session = create_session_with_retries()
    
    try:
        # First, get the tree to find all dependency files
        tree_url = f"https://api.github.com/repos/{repo_full_name}/git/trees/{commit_sha}?recursive=1"
        tree_response = session.get(tree_url, headers=headers, timeout=DEFAULT_TIMEOUT)
        tree_response.raise_for_status()
        
        tree_data = tree_response.json()
        
        # Find all requirements.txt and package.json files
        dependency_file_paths = []
        for item in tree_data.get('tree', []):
            if item['type'] == 'blob':
                path = item['path']
                filename = os.path.basename(path)
                if filename in [PYTHON_DEPS_FILE, NODE_DEPS_FILE]:
                    dependency_file_paths.append(path)
                    logger.info(f"Found dependency file at: {path}")
        
        # Now fetch content for each dependency file found
        headers['Accept'] = "application/vnd.github.v3.raw"
        
        for file_path in dependency_file_paths:
            try:
                file_url = f"https://api.github.com/repos/{repo_full_name}/contents/{file_path}?ref={commit_sha}"
                response = session.get(file_url, headers=headers, timeout=DEFAULT_TIMEOUT)
                
                if response.status_code == 200:
                    dependency_files[file_path] = response.text
                    logger.info(f"Retrieved content for: {file_path}")
                else:
                    logger.warning(f"Could not fetch {file_path}: status {response.status_code}")
                    
            except requests.exceptions.RequestException as e:
                logger.warning(f"Error fetching {file_path}: {str(e)}")
                continue
                
    except requests.exceptions.RequestException as e:
        logger.error(f"Error fetching repository tree: {str(e)}")
    
    if not dependency_files:
        logger.warning("No dependency files found in the repository")
    else:
        logger.info(f"Found {len(dependency_files)} dependency files total")
    
    return dependency_files

def scan_dependencies(dependency_files: Dict[str, str]) -> List[Dict[str, Any]]:
    """
    Scan all dependency files for vulnerabilities.
    
    Args:
        dependency_files: Dictionary of dependency file paths and contents
        
    Returns:
        List of all vulnerability findings
    """
    all_findings = []
    
    with tempfile.TemporaryDirectory() as temp_dir:
        # Process each dependency file found
        for file_path, content in dependency_files.items():
            filename = os.path.basename(file_path)
            
            if filename == PYTHON_DEPS_FILE:
                logger.info(f"Scanning Python dependencies from: {file_path}")
                python_findings = scan_python_dependencies(
                    content, 
                    temp_dir,
                    file_path  # Pass the full path
                )
                all_findings.extend(python_findings)
                
            elif filename == NODE_DEPS_FILE:
                logger.info(f"Scanning Node.js dependencies from: {file_path}")
                node_findings = scan_node_dependencies(
                    content, 
                    temp_dir,
                    file_path  # Pass the full path
                )
                all_findings.extend(node_findings)
    
    return all_findings

def scan_python_dependencies(requirements_content: str, temp_dir: str, file_path: str) -> List[Dict[str, Any]]:
    """
    Scans Python dependencies using the 'safety' tool.
    
    Args:
        requirements_content: Contents of requirements.txt
        temp_dir: Temporary directory for file operations
        file_path: Full path to the requirements file in the repository
        
    Returns:
        List of Python vulnerability findings
    """
    findings = []
    requirements_path = os.path.join(temp_dir, PYTHON_DEPS_FILE)
    
    try:
        with open(requirements_path, "w") as f:
            f.write(requirements_content)
        
        command = ["safety", "check", "--file", requirements_path, "--json"]
        
        result = subprocess.run(command, capture_output=True, text=True, check=False)
        
        if result.returncode != 0:
            try:
                vulnerabilities = json.loads(result.stdout)
                for vuln in vulnerabilities:
                    finding = format_python_vulnerability(vuln, file_path)
                    findings.append(finding)
            except json.JSONDecodeError:
                logger.error(f"Failed to parse safety JSON output. stderr: {result.stderr}")

    except Exception as e:
        logger.error(f"An error occurred during Python vulnerability scanning: {e}", exc_info=True)
    
    return findings

def format_python_vulnerability(vuln: Dict[str, Any], file_path: str) -> Dict[str, Any]:
    """Format a Python vulnerability finding."""
    return {
        "type": "dependency_vulnerability",
        "language": "python",
        "package": vuln.get("package_name", "unknown"),
        "version": vuln.get("affected_versions", "unknown"),
        "severity": vuln.get("severity", "UNKNOWN").upper(),
        "description": vuln.get("description", "No description available"),
        "vulnerability_id": vuln.get("vulnerability_id", "N/A"),
        "file": file_path
    }

def scan_node_dependencies(package_json_content: str, temp_dir: str, file_path: str) -> List[Dict[str, Any]]:
    """
    Scans Node.js dependencies using 'npm audit'.
    
    Args:
        package_json_content: Contents of package.json
        temp_dir: Temporary directory for file operations
        file_path: Full path to the package.json file in the repository
        
    Returns:
        List of Node.js vulnerability findings
    """
    findings = []
    package_json_path = os.path.join(temp_dir, NODE_DEPS_FILE)

    try:
        with open(package_json_path, "w") as f:
            f.write(package_json_content)

        command = ["npm", "audit", "--json", "--prefix", temp_dir]
        
        result = subprocess.run(command, capture_output=True, text=True, check=False)

        if result.returncode != 0:
            try:
                audit_data = json.loads(result.stdout)
                vulnerabilities = audit_data.get("vulnerabilities", {})
                for name, vuln_details in vulnerabilities.items():
                    finding = format_node_vulnerability(name, vuln_details, file_path)
                    findings.append(finding)
            except json.JSONDecodeError:
                logger.error(f"Failed to parse npm audit JSON output. stdout: {result.stdout}, stderr: {result.stderr}")

    except Exception as e:
        logger.error(f"An error occurred during Node.js vulnerability scanning: {e}", exc_info=True)

    return findings

def format_node_vulnerability(name: str, vuln_details: Dict[str, Any], file_path: str) -> Dict[str, Any]:
    """Format a Node.js vulnerability finding."""
    via = vuln_details.get('via', [])
    if isinstance(via, list) and via:
        title = via[0].get('title', 'N/A') if isinstance(via[0], dict) else 'N/A'
        source = via[0].get('source', 'N/A') if isinstance(via[0], dict) else 'N/A'
    else:
        title = 'N/A'
        source = 'N/A'
    
    return {
        "type": "dependency_vulnerability",
        "language": "nodejs",
        "package": name,
        "severity": vuln_details.get("severity", "UNKNOWN").upper(),
        "description": title,
        "vulnerability_id": source,
        "file": file_path
    }