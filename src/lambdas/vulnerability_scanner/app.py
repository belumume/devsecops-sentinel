#!/usr/bin/env python3
"""
DevSecOps Sentinel - Vulnerability Scanner Lambda Function (Production Version)
Scans for vulnerabilities in Python and Node.js dependencies using real tools.
"""

import json
import logging
import os
import subprocess
import tempfile
from typing import Dict, List, Any, Optional

# Configure logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Tool paths to search for scanner binaries
SAFETY_PATHS = ['/opt/python/bin/safety', '/var/lang/bin/python3', 'python3']  # Use Python to run safety module
NPM_PATHS = ['/opt/bin/npm', 'npm', '/usr/bin/npm']

# File patterns
PYTHON_DEPS_FILE = 'requirements.txt'
NODE_DEPS_FILE = 'package.json'

def lambda_handler(event, context):
    """
    Main Lambda handler for vulnerability scanning.
    """
    try:
        logger.info("VulnerabilityScannerFunction invoked - REAL scanning")

        # Debug mode - check layer contents
        if event.get('debug_layer'):
            return debug_layer_contents()

        # Extract repository details
        repo_details = event.get('repo_details', {})
        if not repo_details.get('repository_full_name'):
            return {
                'statusCode': 500,
                'scanner_type': 'vulnerabilities',
                'error': 'Repository name not provided',
                'findings': [],
                'summary': {'total_findings': 0}
            }
        
        repository_full_name = repo_details['repository_full_name']
        pr_number = repo_details.get('pr_number')
        
        logger.info(f"Scanning repository: {repository_full_name}, PR: {pr_number}")
        
        # Get changed files from event
        changed_files = event.get('changed_files', [])
        
        # Find dependency files
        dependency_files = []
        for file_info in changed_files:
            filename = file_info.get('filename', '')
            if filename.endswith(PYTHON_DEPS_FILE) or filename.endswith(NODE_DEPS_FILE):
                dependency_files.append(file_info)
        
        logger.info(f"Found {len(dependency_files)} dependency files total")
        
        # Scan each dependency file
        all_findings = []
        for file_info in dependency_files:
            filename = file_info.get('filename', '')
            content = file_info.get('content', '')
            
            if filename.endswith(PYTHON_DEPS_FILE):
                logger.info(f"Scanning Python dependencies from: {filename}")
                findings = scan_python_dependencies(content, filename)
                all_findings.extend(findings)
            elif filename.endswith(NODE_DEPS_FILE):
                logger.info(f"Scanning Node.js dependencies from: {filename}")
                findings = scan_node_dependencies(content, filename)
                all_findings.extend(findings)
        
        # Create summary
        summary = {
            'total_findings': len(all_findings),
            'by_severity': {},
            'by_language': {}
        }
        
        for finding in all_findings:
            severity = finding.get('severity', 'UNKNOWN')
            language = finding.get('language', 'unknown')
            
            summary['by_severity'][severity] = summary['by_severity'].get(severity, 0) + 1
            summary['by_language'][language] = summary['by_language'].get(language, 0) + 1
        
        logger.info(f"Vulnerability scan completed. Found {len(all_findings)} total vulnerabilities.")
        
        return {
            'statusCode': 200,
            'scanner_type': 'vulnerabilities',
            'findings': all_findings,
            'summary': summary
        }
        
    except Exception as e:
        logger.error(f"Error in vulnerability scanner: {e}", exc_info=True)
        return {
            'statusCode': 500,
            'scanner_type': 'vulnerabilities',
            'error': str(e),
            'findings': [],
            'summary': {'total_findings': 0}
        }

def debug_layer_contents():
    """Debug function to check what's available in the layer"""
    import subprocess

    results = {
        "paths_checked": [],
        "files_found": [],
        "environment": {},
        "tool_checks": []
    }

    # Check environment variables
    results["environment"]["PATH"] = os.environ.get("PATH", "")
    results["environment"]["PYTHONPATH"] = os.environ.get("PYTHONPATH", "")

    # Check common paths
    paths_to_check = ["/opt", "/opt/bin", "/opt/python", "/var/lang/bin", "/usr/bin"]

    for path in paths_to_check:
        results["paths_checked"].append(path)
        if os.path.exists(path):
            try:
                contents = os.listdir(path)
                results["files_found"].append({"path": path, "contents": contents})
            except Exception as e:
                results["files_found"].append({"path": path, "error": str(e)})

    # Check specific tools
    tools_to_check = ["/opt/bin/safety", "/opt/bin/npm", "safety", "npm"]

    for tool in tools_to_check:
        tool_result = {"tool": tool}

        if os.path.exists(tool):
            tool_result["exists"] = True
            tool_result["executable"] = os.access(tool, os.X_OK)
        else:
            tool_result["exists"] = False

        try:
            result = subprocess.run(["which", tool], capture_output=True, text=True)
            tool_result["which_result"] = result.stdout.strip() if result.returncode == 0 else "not found"
        except Exception as e:
            tool_result["which_error"] = str(e)

        results["tool_checks"].append(tool_result)

    return {
        "statusCode": 200,
        "scanner_type": "debug",
        "debug_results": results
    }

def find_tool(tool_paths: List[str]) -> Optional[str]:
    """Find the first available tool from a list of paths."""
    for tool_path in tool_paths:
        # Check if absolute path exists and is executable
        if os.path.exists(tool_path) and os.access(tool_path, os.X_OK):
            return tool_path

        # For relative paths, check in PATH
        if not tool_path.startswith('/'):
            # Check in common directories
            for path_dir in ['/opt/bin', '/usr/bin', '/bin', '/var/lang/bin']:
                full_path = os.path.join(path_dir, tool_path)
                if os.path.exists(full_path) and os.access(full_path, os.X_OK):
                    return full_path

    return None

def scan_python_dependencies(requirements_content: str, file_path: str) -> List[Dict[str, Any]]:
    """
    Scan Python dependencies using safety tool.
    """
    findings = []
    
    if not requirements_content.strip():
        return findings
    
    with tempfile.TemporaryDirectory() as temp_dir:
        requirements_path = os.path.join(temp_dir, PYTHON_DEPS_FILE)
        
        # Use Python to run safety module (since safety is installed as Python package)
        python_cmd = '/var/lang/bin/python3'
        if not os.path.exists(python_cmd):
            logger.error("Python interpreter not found")
            findings.append({
                "type": "tool_error",
                "language": "python",
                "package": "safety",
                "severity": "ERROR",
                "description": "Python interpreter not available",
                "vulnerability_id": "TOOL_MISSING",
                "file": file_path
            })
            return findings
        
        try:
            # Write requirements to temp file
            with open(requirements_path, 'w') as f:
                f.write(requirements_content)
            
            # Run safety check using Python module
            logger.info(f"Using Python to run safety module: {python_cmd}")

            # Set PYTHONPATH to include our layer
            env = os.environ.copy()
            env['PYTHONPATH'] = '/opt/python:' + env.get('PYTHONPATH', '')

            command = [python_cmd, '-m', 'safety', 'check', '--json', '--file', requirements_path]
            
            result = subprocess.run(command, capture_output=True, text=True, check=False, env=env)
            
            if result.returncode == 0:
                # No vulnerabilities found
                logger.info("Safety scan completed - no vulnerabilities found")
                return findings
            
            # Parse safety output
            if result.stdout:
                try:
                    safety_data = json.loads(result.stdout)
                    for vuln in safety_data:
                        finding = {
                            "type": "vulnerability",
                            "language": "python",
                            "package": vuln.get('package_name', 'unknown'),
                            "version": vuln.get('installed_version', 'unknown'),
                            "severity": "HIGH",  # Safety doesn't provide severity, assume high
                            "description": vuln.get('advisory', 'Vulnerability found'),
                            "vulnerability_id": vuln.get('vulnerability_id', 'UNKNOWN'),
                            "file": file_path
                        }
                        findings.append(finding)
                        logger.info(f"Found vulnerability: {finding['package']} {finding['version']}")
                
                except json.JSONDecodeError:
                    logger.error(f"Failed to parse safety output: {result.stdout}")
            
        except Exception as e:
            logger.error(f"Error running safety: {e}")
            findings.append({
                "type": "tool_error",
                "language": "python",
                "package": "safety",
                "severity": "ERROR",
                "description": f"Safety scan failed: {str(e)}",
                "vulnerability_id": "TOOL_ERROR",
                "file": file_path
            })
    
    return findings

def scan_node_dependencies(package_json_content: str, file_path: str) -> List[Dict[str, Any]]:
    """
    Scan Node.js dependencies using npm audit.
    """
    findings = []
    
    if not package_json_content.strip():
        return findings
    
    with tempfile.TemporaryDirectory() as temp_dir:
        package_json_path = os.path.join(temp_dir, NODE_DEPS_FILE)
        
        # Find npm tool
        npm_cmd = find_tool(NPM_PATHS)
        if not npm_cmd:
            logger.error("npm tool not found in production environment")
            findings.append({
                "type": "tool_error",
                "language": "nodejs",
                "package": "npm",
                "severity": "ERROR",
                "description": "npm scanner not available - production tool missing",
                "vulnerability_id": "TOOL_MISSING",
                "file": file_path
            })
            return findings
        
        try:
            # Write package.json to temp file
            with open(package_json_path, 'w') as f:
                f.write(package_json_content)
            
            # Run npm audit
            logger.info(f"Using npm command: {npm_cmd}")

            # If npm_cmd is a shell script, run it with bash
            if npm_cmd == '/opt/bin/npm':
                command = ['/bin/bash', npm_cmd, 'audit', '--json']
            else:
                command = [npm_cmd, 'audit', '--json']

            result = subprocess.run(command, capture_output=True, text=True,
                                  check=False, cwd=temp_dir)
            
            if result.returncode == 0:
                # No vulnerabilities found
                logger.info("npm audit completed - no vulnerabilities found")
                return findings
            
            # Parse npm audit output
            if result.stdout:
                try:
                    audit_data = json.loads(result.stdout)
                    vulnerabilities = audit_data.get('vulnerabilities', {})
                    
                    for package_name, vuln_info in vulnerabilities.items():
                        finding = {
                            "type": "vulnerability",
                            "language": "nodejs",
                            "package": package_name,
                            "version": vuln_info.get('version', 'unknown'),
                            "severity": vuln_info.get('severity', 'UNKNOWN').upper(),
                            "description": vuln_info.get('title', 'Vulnerability found'),
                            "vulnerability_id": str(vuln_info.get('cwe', 'UNKNOWN')),
                            "file": file_path
                        }
                        findings.append(finding)
                        logger.info(f"Found vulnerability: {finding['package']} {finding['version']}")
                
                except json.JSONDecodeError:
                    logger.error(f"Failed to parse npm audit output: {result.stdout}")
            
        except Exception as e:
            logger.error(f"Error running npm audit: {e}")
            findings.append({
                "type": "tool_error",
                "language": "nodejs",
                "package": "npm",
                "severity": "ERROR",
                "description": f"npm audit failed: {str(e)}",
                "vulnerability_id": "TOOL_ERROR",
                "file": file_path
            })
    
    return findings
