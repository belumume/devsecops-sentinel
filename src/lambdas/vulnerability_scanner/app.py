import os
import json
import re
import logging
import subprocess
import tempfile
from typing import List, Dict, Any, Optional

import boto3
import requests

from sentinel_utils.utils import (
    get_github_token,
    create_session_with_retries,
    format_error_response,
    format_success_response,
    DEFAULT_TIMEOUT
)

# Configure logging
logger = logging.getLogger(__name__)
logger.setLevel(os.environ.get("LOG_LEVEL", "INFO"))

# Initialize AWS clients
secrets_manager = boto3.client("secretsmanager")

# Scanner type constant
SCANNER_TYPE = "vulnerabilities"

# Dependency file names
PYTHON_DEPS_FILE = "requirements.txt"
NODE_DEPS_FILE = "package.json"

def lambda_handler(event: Dict[str, Any], context: Any) -> Dict[str, Any]:
    """
    Lambda handler that scans for vulnerabilities in dependencies using real tools.
    Supports Python (requirements.txt) and Node.js (package.json).
    
    Args:
        event: Lambda event containing repo_details
        context: Lambda context
        
    Returns:
        Standardized response with vulnerability findings
    """
    logger.info("VulnerabilityScannerFunction invoked - REAL scanning")
    
    try:
        repo_details = event.get("repo_details", {})
        repo_full_name = repo_details.get("repository_full_name", "")
        pr_number = repo_details.get("pr_number", 0)
        commit_sha = repo_details.get("commit_sha", "")
        
        if not repo_full_name:
            raise ValueError("Repository name not provided")
        
        logger.info(f"Scanning repository: {repo_full_name}, PR: {pr_number}")
        
        github_token = get_github_token()
        
        dependency_files = get_dependency_files(repo_full_name, commit_sha, github_token)
        
        all_findings = scan_dependencies(dependency_files)
        
        logger.info(f"Vulnerability scan completed. Found {len(all_findings)} total vulnerabilities.")
        
        return format_success_response(SCANNER_TYPE, all_findings)
        
    except Exception as e:
        logger.error(f"Error in vulnerability scanning: {str(e)}", exc_info=True)
        return format_error_response(SCANNER_TYPE, e)

def get_dependency_files(repo_full_name: str, commit_sha: str, github_token: str) -> Dict[str, str]:
    """
    Get dependency files from the repository at a specific commit.
    
    Args:
        repo_full_name: Full name of the repository (org/repo)
        commit_sha: Commit SHA to fetch files from
        github_token: GitHub authentication token
        
    Returns:
        Dictionary mapping file names to their contents
    """
    dependency_files = {}
    
    files_to_check = [PYTHON_DEPS_FILE, NODE_DEPS_FILE]
    
    headers = {
        "Authorization": f"token {github_token}",
        "Accept": "application/vnd.github.v3.raw"
    }
    
    # Create session with retries
    session = create_session_with_retries()
    
    for filename in files_to_check:
        try:
            # Add the commit SHA to the URL to get the file from the correct commit
            file_url = f"https://api.github.com/repos/{repo_full_name}/contents/{filename}?ref={commit_sha}"
            response = session.get(file_url, headers=headers, timeout=DEFAULT_TIMEOUT)
            
            if response.status_code == 200:
                dependency_files[filename] = response.text
                logger.info(f"Found dependency file: {filename}")
            elif response.status_code == 404:
                logger.debug(f"Dependency file not found: {filename}")
            else:
                logger.warning(f"Unexpected status code {response.status_code} for {filename}")
                
        except requests.exceptions.RequestException as e:
            logger.warning(f"Could not fetch {filename}: {str(e)}")
            continue
    
    return dependency_files

def scan_dependencies(dependency_files: Dict[str, str]) -> List[Dict[str, Any]]:
    """
    Scan all dependency files for vulnerabilities.
    
    Args:
        dependency_files: Dictionary of dependency file names and contents
        
    Returns:
        List of all vulnerability findings
    """
    all_findings = []
    
    with tempfile.TemporaryDirectory() as temp_dir:
        if PYTHON_DEPS_FILE in dependency_files:
            logger.info(f"Found {PYTHON_DEPS_FILE}, scanning for Python vulnerabilities.")
            python_findings = scan_python_dependencies(
                dependency_files[PYTHON_DEPS_FILE], 
                temp_dir
            )
            all_findings.extend(python_findings)

        if NODE_DEPS_FILE in dependency_files:
            logger.info(f"Found {NODE_DEPS_FILE}, scanning for Node.js vulnerabilities.")
            node_findings = scan_node_dependencies(
                dependency_files[NODE_DEPS_FILE], 
                temp_dir
            )
            all_findings.extend(node_findings)
    
    return all_findings

def scan_python_dependencies(requirements_content: str, temp_dir: str) -> List[Dict[str, Any]]:
    """
    Scans Python dependencies using the 'safety' tool.
    
    Args:
        requirements_content: Contents of requirements.txt
        temp_dir: Temporary directory for file operations
        
    Returns:
        List of Python vulnerability findings
    """
    findings = []
    requirements_path = os.path.join(temp_dir, PYTHON_DEPS_FILE)
    
    try:
        with open(requirements_path, "w") as f:
            f.write(requirements_content)
        
        command = ["safety", "check", "--file", requirements_path, "--json"]
        
        result = subprocess.run(command, capture_output=True, text=True, check=False)
        
        if result.returncode != 0:
            try:
                vulnerabilities = json.loads(result.stdout)
                for vuln in vulnerabilities:
                    finding = format_python_vulnerability(vuln)
                    findings.append(finding)
            except json.JSONDecodeError:
                logger.error(f"Failed to parse safety JSON output. stderr: {result.stderr}")

    except Exception as e:
        logger.error(f"An error occurred during Python vulnerability scanning: {e}", exc_info=True)
    
    return findings

def format_python_vulnerability(vuln: Dict[str, Any]) -> Dict[str, Any]:
    """Format a Python vulnerability finding."""
    return {
        "type": "dependency_vulnerability",
        "language": "python",
        "package": vuln.get("package_name", "unknown"),
        "version": vuln.get("affected_versions", "unknown"),
        "severity": vuln.get("severity", "UNKNOWN").upper(),
        "description": vuln.get("description", "No description available"),
        "vulnerability_id": vuln.get("vulnerability_id", "N/A"),
        "file": PYTHON_DEPS_FILE
    }

def scan_node_dependencies(package_json_content: str, temp_dir: str) -> List[Dict[str, Any]]:
    """
    Scans Node.js dependencies using 'npm audit'.
    
    Args:
        package_json_content: Contents of package.json
        temp_dir: Temporary directory for file operations
        
    Returns:
        List of Node.js vulnerability findings
    """
    findings = []
    package_json_path = os.path.join(temp_dir, NODE_DEPS_FILE)

    try:
        with open(package_json_path, "w") as f:
            f.write(package_json_content)

        command = ["npm", "audit", "--json", "--prefix", temp_dir]
        
        result = subprocess.run(command, capture_output=True, text=True, check=False)

        if result.returncode != 0:
            try:
                audit_data = json.loads(result.stdout)
                vulnerabilities = audit_data.get("vulnerabilities", {})
                for name, vuln_details in vulnerabilities.items():
                    finding = format_node_vulnerability(name, vuln_details)
                    findings.append(finding)
            except json.JSONDecodeError:
                logger.error(f"Failed to parse npm audit JSON output. stdout: {result.stdout}, stderr: {result.stderr}")

    except Exception as e:
        logger.error(f"An error occurred during Node.js vulnerability scanning: {e}", exc_info=True)

    return findings

def format_node_vulnerability(name: str, vuln_details: Dict[str, Any]) -> Dict[str, Any]:
    """Format a Node.js vulnerability finding."""
    via = vuln_details.get('via', [])
    if isinstance(via, list) and via:
        title = via[0].get('title', 'N/A') if isinstance(via[0], dict) else 'N/A'
        source = via[0].get('source', 'N/A') if isinstance(via[0], dict) else 'N/A'
    else:
        title = 'N/A'
        source = 'N/A'
    
    return {
        "type": "dependency_vulnerability",
        "language": "nodejs",
        "package": name,
        "severity": vuln_details.get("severity", "UNKNOWN").upper(),
        "description": title,
        "vulnerability_id": source,
        "file": NODE_DEPS_FILE
    }